<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Anki Deck Generator</title>
    <style>
      :root {
        --primary-color: #3a7bd5;
        --secondary-color: #5794e5;
        --accent-color: #ff7e5f;
        --background-color: #f7f9fc;
        --card-color: #ffffff;
        --text-color: #333333;
        --border-radius: 12px;
        --box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        --transition: all 0.3s ease;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
      }

      body {
        background-color: var(--background-color);
        color: var(--text-color);
        line-height: 1.6;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        text-align: center;
        padding: 2rem 0;
        background-color: var(--card-color);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      }

      h1 {
        color: var(--primary-color);
        font-size: 2rem;
        font-weight: 600;
      }

      .subtitle {
        color: #666;
        font-weight: 400;
        margin-top: 0.5rem;
      }

      .container {
        max-width: 1000px;
        margin: 0 auto;
        padding: 2rem;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      .method-selection {
        display: flex;
        justify-content: center;
        margin: 2rem 0;
        gap: 1.5rem;
      }

      .method-card {
        background-color: var(--card-color);
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
        padding: 2rem;
        text-align: center;
        cursor: pointer;
        transition: var(--transition);
        flex: 1;
        max-width: 200px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border: 2px solid transparent;
        position: relative;
        z-index: 1;
      }

      .method-card:hover {
        transform: translateY(-5px);
        border-color: var(--primary-color);
      }

      .method-card h3 {
        margin: 1rem 0;
        color: var(--primary-color);
      }

      .method-card p {
        color: #666;
        font-size: 0.9rem;
      }

      .method-icon {
        width: 60px;
        height: 60px;
        background-color: rgba(58, 123, 213, 0.1);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 1rem;
      }

      .method-icon svg {
        width: 30px;
        height: 30px;
        fill: var(--primary-color);
      }

      .page {
        display: none;
      }

      .page.active {
        display: block;
        animation: fadeIn 0.5s ease;
      }

      .card {
        background-color: var(--card-color);
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
        padding: 2.5rem;
        margin-bottom: 2rem;
        max-width: 1200px;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
      }

      .card h2 {
        color: var(--primary-color);
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid #f0f0f0;
        font-weight: 600;
      }

      /* Carousel Styles */
      .carousel-container {
        margin-top: 2rem;
        position: relative;
        overflow: hidden;
        padding-bottom: 2rem;
      }

      .carousel-track {
        display: flex;
        transition: transform 0.4s ease-in-out;
      }

      .carousel-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 2rem;
        gap: 1rem;
      }

      .carousel-btn {
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        cursor: pointer;
        transition: var(--transition);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      .carousel-btn:hover {
        background-color: var(--secondary-color);
        transform: scale(1.1);
      }

      .carousel-btn:disabled {
        background-color: #ccc;
        cursor: not-allowed;
        transform: none;
      }

      .carousel-status {
        font-size: 1rem;
        font-weight: 500;
        color: var(--primary-color);
      }

      .carousel-pagination {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        margin-top: 1rem;
      }

      .pagination-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: #ccc;
        cursor: pointer;
        transition: var(--transition);
      }

      .pagination-dot.active {
        background-color: var(--primary-color);
        transform: scale(1.2);
      }

      /* QA Pair Styles for Carousel */
      .qa-pair {
        min-width: 100%;
        background-color: #fff;
        border-radius: var(--border-radius);
        padding: 2rem;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        border: 1px solid #e0e0e0;
        position: relative;
        animation: fadeIn 0.5s ease;
      }

      .qa-pair::before {
        content: "";
        position: absolute;
        top: 0;
        left: 12px;
        width: 30px;
        height: 8px;
        background-color: rgba(58, 123, 213, 0.6);
        border-radius: 0 0 15px 15px;
      }

      .qa-pair::after {
        content: "";
        position: absolute;
        top: 0;
        right: 12px;
        width: 30px;
        height: 8px;
        background-color: rgba(58, 123, 213, 0.6);
        border-radius: 0 0 15px 15px;
      }

      .form-group {
        margin-bottom: 1.5rem;
      }

      label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
      }

      input[type="text"],
      input[type="number"],
      textarea {
        width: 100%;
        padding: 0.8rem 1rem;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        font-size: 1rem;
        transition: var(--transition);
        background-color: #f9f9f9;
      }

      input[type="text"]:focus,
      input[type="number"]:focus,
      textarea:focus {
        outline: none;
        border-color: var(--primary-color);
        background-color: #fff;
        box-shadow: 0 0 0 3px rgba(58, 123, 213, 0.1);
      }

      .file-input {
        position: relative;
        display: inline-block;
        width: 100%;
      }

      .file-input input[type="file"] {
        position: absolute;
        left: 0;
        top: 0;
        opacity: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
      }

      .file-input-label {
        display: flex;
        padding: 3rem 2rem;
        background-color: #f9f9f9;
        border: 2px dashed #ddd;
        border-radius: var(--border-radius);
        text-align: center;
        cursor: pointer;
        transition: var(--transition);
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .file-input:hover .file-input-label {
        border-color: var(--primary-color);
        background-color: rgba(58, 123, 213, 0.05);
      }

      .file-icon {
        margin-bottom: 1rem;
      }

      .file-name {
        margin-top: 1rem;
        font-size: 0.9rem;
        color: #666;
      }

      button {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 0.8rem 1.5rem;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-size: 1rem;
        font-weight: 500;
        transition: var(--transition);
        width: 100%;
        margin-top: 1rem;
      }

      button:hover {
        background-color: var(--secondary-color);
      }

      button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }

      .btn-secondary {
        background-color: #f0f0f0;
        color: #333;
      }

      .btn-secondary:hover {
        background-color: #e0e0e0;
      }

      .add-card-btn {
        background-color: white;
        color: var(--primary-color);
        border: 2px dashed var(--primary-color);
        padding: 1rem;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-weight: 500;
        transition: var(--transition);
        display: block;
        width: 100%;
        max-width: 280px;
        margin: 2rem auto 0;
        text-align: center;
      }

      .add-card-btn:hover {
        background-color: rgba(58, 123, 213, 0.05);
      }

      .status-container {
        margin-top: 2rem;
        padding: 1.5rem;
        border-radius: var(--border-radius);
        background-color: #f8f9fa;
        border-left: 4px solid var(--primary-color);
        text-align: center;
      }

      .status-title {
        font-weight: 600;
        margin-bottom: 1rem;
        font-size: 1.1rem;
      }

      .progress-container {
        height: 8px;
        background-color: #e9ecef;
        border-radius: 5px;
        margin: 1.5rem 0;
        overflow: hidden;
        position: relative;
      }

      .progress-bar {
        height: 100%;
        background-color: var(--primary-color);
        width: 0%;
        transition: width 0.5s ease;
        position: relative;
      }

      .hidden {
        display: none !important;
      }

      .success {
        border-left-color: #28a745;
      }

      .error {
        border-left-color: #dc3545;
      }

      .btn-back {
        background-color: transparent;
        color: var(--primary-color);
        border: 1px solid var(--primary-color);
        margin-right: 1rem;
      }

      .btn-back:hover {
        background-color: rgba(58, 123, 213, 0.1);
      }

      .actions {
        display: flex;
        margin-top: 2rem;
      }

      .download-btn {
        background-color: #28a745;
      }

      .download-btn:hover {
        background-color: #218838;
      }

      /* Loading animation */
      .loading-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.9);
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .loading-container.show {
        display: flex;
      }

      .flashcard-loader {
        position: relative;
        width: 200px;
        height: 120px;
        perspective: 600px;
        margin-bottom: 2rem;
      }

      .flashcard {
        position: absolute;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
        animation: cardFlip 3s infinite ease-in-out;
        background-color: white;
        border-radius: 12px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
      }

      .flashcard-front,
      .flashcard-back {
        position: absolute;
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 12px;
        font-weight: 600;
        font-size: 1.2rem;
        padding: 1.5rem;
        text-align: center;
      }

      .flashcard-front {
        background-color: white;
        color: var(--primary-color);
      }

      .flashcard-back {
        background-color: var(--primary-color);
        color: white;
        transform: rotateY(180deg);
      }

      @keyframes cardFlip {
        0%,
        20% {
          transform: rotateY(0);
        }
        45%,
        70% {
          transform: rotateY(180deg);
        }
        95%,
        100% {
          transform: rotateY(0);
        }
      }

      .loading-text {
        font-size: 1.2rem;
        color: var(--primary-color);
        margin-top: 1rem;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .edit-question,
      .edit-answer {
        width: 100%;
        padding: 0.8rem;
        border: 1px solid #eee;
        border-radius: 8px;
        font-size: 0.95rem;
        transition: var(--transition);
        margin-bottom: 0.8rem;
        resize: vertical;
        background-color: #fcfcfc;
        min-height: 70px;
      }

      .edit-question {
        border-bottom: 2px dashed #ccc;
      }

      .edit-question:focus,
      .edit-answer:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(58, 123, 213, 0.1);
        background-color: white;
      }

      .qa-pair-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid #f1f1f1;
      }

      .qa-pair-num {
        font-weight: 600;
        color: var(--primary-color);
        font-size: 0.9rem;
        background-color: rgba(58, 123, 213, 0.1);
        padding: 0.3rem 0.8rem;
        border-radius: 20px;
      }

      .remove-pair {
        background: none;
        border: none;
        color: #dc3545;
        cursor: pointer;
        padding: 0.3rem;
        margin: 0;
        font-size: 1.1rem;
        opacity: 0.7;
        transition: opacity 0.2s ease;
      }

      .remove-pair:hover {
        opacity: 1;
      }

      /* Direct text input page */
      .direct-text-wrap {
        position: relative;
      }

      .word-count {
        position: absolute;
        bottom: 0.5rem;
        right: 0.5rem;
        font-size: 0.8rem;
        color: #666;
      }

      /* Notification */
      .notification {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        background-color: #28a745;
        color: white;
        padding: 1rem 1.5rem;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 1000;
      }

      .notification.show {
        opacity: 1;
      }

      /* View toggle styles */
      .view-toggle {
        display: flex;
        justify-content: center;
        margin: 1.5rem 0;
        gap: 1rem;
      }

      .view-btn {
        background-color: #f0f0f0;
        color: #333;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 500;
        transition: var(--transition);
      }

      .view-btn.active {
        background-color: var(--primary-color);
        color: white;
      }

      .view-btn:hover:not(.active) {
        background-color: #e0e0e0;
      }

      /* Grid layout styles */
      .grid-container {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 1.5rem;
        margin-top: 2rem;
        max-height: 70vh;
        overflow-y: auto;
        padding: 0.5rem;
        width: 100%;
      }

      .grid-item {
        background-color: #fff;
        border-radius: var(--border-radius);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        border: 1px solid #e0e0e0;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        position: relative;
        max-width: 100%;
      }

      .grid-item::before {
        content: "";
        position: absolute;
        top: 0;
        left: 12px;
        width: 30px;
        height: 8px;
        background-color: rgba(58, 123, 213, 0.6);
        border-radius: 0 0 15px 15px;
      }

      .grid-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid #f1f1f1;
      }

      .grid-item .qa-pair-num {
        font-size: 0.8rem;
      }

      .grid-item .edit-question,
      .grid-item .edit-answer {
        min-height: 60px;
      }

      .card-count-estimator {
        background-color: #f8f9fa;
        border-radius: var(--border-radius);
        padding: 1.5rem;
        margin-bottom: 1rem;
      }

      .estimate-message {
        font-size: 1.1rem;
        margin-bottom: 1rem;
        text-align: center;
        line-height: 1.5;
      }

      .density-selector {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        margin-bottom: 1.5rem;
      }

      .density-btn {
        background-color: #f0f0f0;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        padding: 0.5rem 1rem;
        cursor: pointer;
        transition: all 0.2s ease;
        flex: 1;
        max-width: 150px;
        color: #333333; /* Darker text color for better contrast */
        font-weight: 500; /* Make text slightly bolder */
      }

      .density-btn-wrapper {
        position: relative;
        flex: 1;
        max-width: 150px;
      }

      .density-tooltip {
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background-color: #333;
        color: white;
        padding: 0.5rem;
        border-radius: 4px;
        font-size: 0.8rem;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s, visibility 0.2s;
        z-index: 10;
        margin-bottom: 5px;
      }

      .density-tooltip::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: #333 transparent transparent transparent;
      }

      .density-btn-wrapper:hover .density-tooltip {
        opacity: 1;
        visibility: visible;
      }

      .density-btn:hover {
        background-color: #e0e0e0;
        border-color: #ccc;
      }

      .density-btn.active {
        background-color: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Add subtle shadow for emphasis */
      }
      .custom-count-container {
        border-top: 1px solid #eee;
        padding-top: 1rem;
      }

      .custom-count-toggle {
        display: flex;
        align-items: center;
        cursor: pointer;
        user-select: none;
      }

      .custom-count-toggle input {
        margin-right: 0.5rem;
      }

      .custom-count-input {
        margin-top: 1rem;
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .custom-count-input input {
        width: 80px;
      }

      .hidden {
        display: none !important;
      }

      @keyframes countHighlight {
        0% {
          color: var(--primary-color);
          transform: scale(1);
        }
        50% {
          color: var(--primary-color);
          transform: scale(1.2);
        }
        100% {
          color: inherit;
          transform: scale(1);
        }
      }

      .count-updated {
        animation: countHighlight 0.6s ease;
      }

      /* Make the count more prominent */
      #estimated-card-count,
      #text-estimated-card-count,
      #youtube-estimated-card-count {
        font-weight: 600;
        color: var(--primary-color);
        padding: 0 3px;
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        .card {
          padding: 1.5rem;
        }

        .method-selection {
          flex-direction: column;
          align-items: center;
        }

        .method-card {
          max-width: 100%;
          width: 100%;
        }

        .grid-container {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Anki Deck Generator</h1>
      <p class="subtitle">
        Create flashcards easily from PDFs or custom content
      </p>
    </header>

    <div class="container">
      <!-- Method Selection Page -->
      <div class="page active" id="method-selection">
        <div class="method-selection">
          <div class="method-card" id="pdf-method">
            <div class="method-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path
                  d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M9,13H7V11H9V13M9,17H7V15H9V17M16,13H11V11H16V13M16,17H11V15H16V17Z"
                />
              </svg>
            </div>
            <h3>PDF Upload</h3>
            <p>Generate flashcards from your PDF documents</p>
          </div>

          <div class="method-card" id="text-method">
            <div class="method-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path
                  d="M19 5V19H5V5H19M21 3H3V21H21V3M17 17H7V16H17V17M17 15H7V14H17V15M17 12H7V7H17V12Z"
                />
              </svg>
            </div>
            <h3>Direct Text</h3>
            <p>Create flashcards from your own text</p>
          </div>

          <div class="method-card" id="manual-method">
            <div class="method-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path
                  d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z"
                />
              </svg>
            </div>
            <h3>Manual Entry</h3>
            <p>Create custom question-answer pairs</p>
          </div>

          <div class="method-card" id="youtube-method">
            <div class="method-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path
                  d="M10,15L15.19,12L10,9V15M21.56,7.17C21.69,7.64 21.78,8.27 21.84,9.07C21.91,9.87 21.94,10.56 21.94,11.16L22,12C22,14.19 21.84,15.8 21.56,16.83C21.31,17.73 20.73,18.31 19.83,18.56C19.36,18.69 18.5,18.78 17.18,18.84C15.88,18.91 14.69,18.94 13.59,18.94L12,19C7.81,19 5.2,18.84 4.17,18.56C3.27,18.31 2.69,17.73 2.44,16.83C2.31,16.36 2.22,15.73 2.16,14.93C2.09,14.13 2.06,13.44 2.06,12.84L2,12C2,9.81 2.16,8.2 2.44,7.17C2.69,6.27 3.27,5.69 4.17,5.44C4.64,5.31 5.5,5.22 6.82,5.16C8.12,5.09 9.31,5.06 10.41,5.06L12,5C16.19,5 18.8,5.16 19.83,5.44C20.73,5.69 21.31,6.27 21.56,7.17Z"
                />
              </svg>
            </div>
            <h3>YouTube Video</h3>
            <p>Generate flashcards from YouTube video</p>
          </div>
        </div>
      </div>

      <!-- PDF Upload Page -->
      <div class="page" id="pdf-upload">
        <div class="card">
          <h2>Upload PDF</h2>
          <p>
            Upload a PDF document to automatically generate question-answer
            pairs.
          </p>
          <form id="pdf-form">
            <div class="form-group">
              <div class="file-input">
                <input type="file" id="pdf-file" accept=".pdf" />
                <label for="pdf-file" class="file-input-label">
                  <div class="file-icon">
                    <svg width="48" height="48" viewBox="0 0 24 24">
                      <path
                        fill="#3a7bd5"
                        d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"
                      />
                      <path
                        fill="#3a7bd5"
                        d="M12,17V14H13V13H10V14H11V17H10V18H13V17H12Z"
                      />
                      <path fill="#3a7bd5" d="M14,9H13V11H14V9Z" />
                      <path fill="#3a7bd5" d="M9,9H10.5V11H9V9Z" />
                      <path fill="#3a7bd5" d="M9,13H10V14H9V13Z" />
                    </svg>
                  </div>
                  <span>Choose a PDF file or drag it here</span>
                </label>
              </div>
              <div class="file-name" id="pdf-file-name"></div>
            </div>

            <div class="form-group">
              <label>Number of Q&A Pairs to Generate</label>
              <div class="card-count-estimator">
                <p class="estimate-message">
                  We'll generate approximately
                  <span id="estimated-card-count">10</span> cards based on your
                  content
                </p>

                <div class="density-selector">
                  <div class="density-btn-wrapper">
                    <div class="density-tooltip">
                      Approximately <span class="fewer-count">7</span> cards
                    </div>
                    <button
                      type="button"
                      class="density-btn"
                      data-density="fewer"
                    >
                      Fewer
                    </button>
                  </div>
                  <div class="density-btn-wrapper">
                    <div class="density-tooltip">
                      Approximately
                      <span class="recommended-count">10</span> cards
                    </div>
                    <button
                      type="button"
                      class="density-btn active"
                      data-density="recommended"
                    >
                      Recommended
                    </button>
                  </div>
                  <div class="density-btn-wrapper">
                    <div class="density-tooltip">
                      Approximately <span class="more-count">13</span> cards
                    </div>
                    <button
                      type="button"
                      class="density-btn"
                      data-density="more"
                    >
                      More
                    </button>
                  </div>
                </div>

                <div class="custom-count-container">
                  <label for="custom-count-toggle" class="custom-count-toggle">
                    <input type="checkbox" id="custom-count-toggle" />
                    <span>Specify custom count</span>
                  </label>

                  <div class="custom-count-input hidden">
                    <label for="num-pairs">Custom count:</label>
                    <input
                      type="number"
                      id="num-pairs"
                      min="1"
                      max="50"
                      value="10"
                    />
                  </div>
                </div>
              </div>
            </div>

            <div class="actions">
              <button type="button" class="btn-back" id="pdf-back-btn">
                Back
              </button>
              <button type="submit" id="upload-btn">Generate Flashcards</button>
            </div>
          </form>
        </div>
      </div>

      <!-- Direct Text Page -->
      <div class="page" id="text-input">
        <div class="card">
          <h2>Direct Text Input</h2>
          <p>Enter or paste your text to generate question-answer pairs.</p>
          <form id="text-form">
            <div class="form-group">
              <label for="direct-text">Paste Your Text</label>
              <div class="direct-text-wrap">
                <textarea
                  id="direct-text"
                  rows="12"
                  placeholder="Paste your text here (minimum 100 characters)"
                  required
                ></textarea>
                <div class="word-count">0 characters</div>
              </div>
            </div>

            <div class="form-group">
              <label>Number of Q&A Pairs to Generate</label>
              <div class="card-count-estimator">
                <p class="estimate-message">
                  We'll generate approximately
                  <span id="text-estimated-card-count">10</span> cards based on
                  your content
                </p>

                <div class="density-selector">
                  <div class="density-btn-wrapper">
                    <div class="density-tooltip">
                      Approximately <span class="fewer-count">7</span> cards
                    </div>
                    <button
                      type="button"
                      class="density-btn"
                      data-density="fewer"
                    >
                      Fewer
                    </button>
                  </div>
                  <div class="density-btn-wrapper">
                    <div class="density-tooltip">
                      Approximately
                      <span class="recommended-count">10</span> cards
                    </div>
                    <button
                      type="button"
                      class="density-btn active"
                      data-density="recommended"
                    >
                      Recommended
                    </button>
                  </div>
                  <div class="density-btn-wrapper">
                    <div class="density-tooltip">
                      Approximately <span class="more-count">13</span> cards
                    </div>
                    <button
                      type="button"
                      class="density-btn"
                      data-density="more"
                    >
                      More
                    </button>
                  </div>
                </div>

                <div class="custom-count-container">
                  <label
                    for="text-custom-count-toggle"
                    class="custom-count-toggle"
                  >
                    <input type="checkbox" id="text-custom-count-toggle" />
                    <span>Specify custom count</span>
                  </label>

                  <div class="custom-count-input hidden">
                    <label for="text-num-pairs">Custom count:</label>
                    <input
                      type="number"
                      id="text-num-pairs"
                      min="1"
                      max="50"
                      value="10"
                    />
                  </div>
                </div>
              </div>
            </div>

            <div class="actions">
              <button type="button" class="btn-back" id="text-back-btn">
                Back
              </button>
              <button type="submit">Generate Flashcards</button>
            </div>
          </form>
        </div>
      </div>

      <!-- Manual Entry Page -->
      <div class="page" id="manual-entry">
        <div class="card">
          <h2>Manual Q&A Entry</h2>
          <p>Create your own question-answer pairs for your Anki deck.</p>
          <form id="manual-form">
            <div class="form-group">
              <label for="deck-title">Deck Title</label>
              <input
                type="text"
                id="deck-title"
                required
                placeholder="Enter a title for your deck"
              />
            </div>

            <div id="qa-pairs-container">
              <div class="qa-pair">
                <div class="qa-pair-header">
                  <div class="qa-pair-num">Card #1</div>
                </div>
                <div class="form-group">
                  <label for="question-0">Question</label>
                  <input
                    type="text"
                    id="question-0"
                    class="question-input"
                    required
                    placeholder="Enter your question"
                  />
                </div>
                <div class="form-group">
                  <label for="answer-0">Answer</label>
                  <textarea
                    id="answer-0"
                    class="answer-input"
                    required
                    placeholder="Enter your answer"
                    rows="3"
                  ></textarea>
                </div>
              </div>
            </div>

            <button type="button" id="add-pair" class="add-card-btn">
              + Add Another Flashcard
            </button>

            <div class="actions">
              <button type="button" class="btn-back" id="manual-back-btn">
                Back
              </button>
              <button type="submit" id="create-deck-btn">
                Generate Anki Deck
              </button>
            </div>
          </form>
        </div>
      </div>

      <!--Youtube Input Page -->
      <div class="page" id="youtube-input">
        <div class="card">
          <h2>YouTube Video To Flashcards</h2>
          <p>Enter a YouTube video URL to generate question-answer pairs.</p>
          <form id="youtube-form">
            <div class="form-group">
              <label for="youtube-url">YouTube Video URL</label>
              <input
                type="text"
                id="youtube-url"
                required
                placeholder="https://www.youtube.com/watch?v=..."
                pattern="^(https?://)?(www\.)?(youtube\.com|youtu\.be)/.+"
                title="Please enter a valid YouTube URL"
              />
            </div>

            <div class="form-group">
              <label>Number of Q&A Pairs to Generate</label>
              <div class="card-count-estimator">
                <p class="estimate-message">
                  We'll generate approximately
                  <span id="youtube-estimated-card-count">10</span> cards based
                  on your content
                </p>

                <div class="density-selector">
                  <div class="density-btn-wrapper">
                    <div class="density-tooltip">
                      Approximately <span class="fewer-count">7</span> cards
                    </div>
                    <button
                      type="button"
                      class="density-btn"
                      data-density="fewer"
                    >
                      Fewer
                    </button>
                  </div>
                  <div class="density-btn-wrapper">
                    <div class="density-tooltip">
                      Approximately
                      <span class="recommended-count">10</span> cards
                    </div>
                    <button
                      type="button"
                      class="density-btn active"
                      data-density="recommended"
                    >
                      Recommended
                    </button>
                  </div>
                  <div class="density-btn-wrapper">
                    <div class="density-tooltip">
                      Approximately <span class="more-count">13</span> cards
                    </div>
                    <button
                      type="button"
                      class="density-btn"
                      data-density="more"
                    >
                      More
                    </button>
                  </div>
                </div>

                <div class="custom-count-container">
                  <label
                    for="youtube-custom-count-toggle"
                    class="custom-count-toggle"
                  >
                    <input type="checkbox" id="youtube-custom-count-toggle" />
                    <span>Specify custom count</span>
                  </label>

                  <div class="custom-count-input hidden">
                    <label for="youtube-num-pairs">Custom count:</label>
                    <input
                      type="number"
                      id="youtube-num-pairs"
                      min="1"
                      max="50"
                      value="10"
                    />
                  </div>
                </div>
              </div>
            </div>

            <div class="actions">
              <button type="button" class="btn-back" id="youtube-back-btn">
                Back
              </button>
              <button type="submit">Generate Flashcards</button>
            </div>
          </form>
        </div>
      </div>

      <!-- QA Review Page -->
      <div class="page" id="qa-review">
        <div class="card">
          <h2>Review Generated Flashcards</h2>
          <p>Review and edit your flashcards before creating your Anki deck.</p>

          <div class="view-toggle">
            <button id="carousel-view-btn" class="view-btn active">
              Carousel View
            </button>
            <button id="grid-view-btn" class="view-btn">Grid View</button>
          </div>

          <div class="carousel-container" id="flashcard-carousel">
            <div class="carousel-track" id="carousel-track"></div>

            <div class="carousel-controls">
              <button class="carousel-btn" id="prev-btn" disabled>&lt;</button>
              <div class="carousel-status">
                Card <span id="current-card">1</span> of
                <span id="total-cards">10</span>
              </div>
              <button class="carousel-btn" id="next-btn">&gt;</button>
            </div>

            <div class="carousel-pagination" id="carousel-pagination"></div>

            <button type="button" id="add-new-card" class="add-card-btn">
              + Add New Flashcard
            </button>
          </div>

          <div class="grid-container hidden" id="flashcard-grid"></div>

          <button
            type="button"
            id="grid-add-new-card"
            class="add-card-btn hidden"
          >
            + Add New Flashcard
          </button>

          <div class="actions">
            <button type="button" class="btn-back" id="review-back-btn">
              Back
            </button>
            <button id="create-deck-from-qa" class="download-btn">
              Create Anki Deck
            </button>
          </div>
        </div>
      </div>

      <!-- Download Page -->
      <div class="page" id="download-page">
        <div class="card">
          <h2>Your Anki Deck is Ready!</h2>
          <div class="status-container success">
            <div class="status-title">Deck Created Successfully!</div>
            <p>Your Anki deck has been created and is now ready to download.</p>
            <button id="download-deck" class="download-btn">
              Download Anki Deck
            </button>
            <p style="margin-top: 1.5rem">
              <button id="start-over-btn" class="btn-secondary">
                Create Another Deck
              </button>
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- Loading Animation -->
    <div class="loading-container" id="loading-container">
      <div class="flashcard-loader">
        <div class="flashcard">
          <div class="flashcard-front">Creating Flashcards...</div>
          <div class="flashcard-back">Processing Content</div>
        </div>
      </div>
      <div class="loading-text" id="loading-text">
        Analyzing your content...
      </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification">Deck created successfully!</div>

    <script>
      const API_BASE_URL = "http://localhost:8000";

      document.addEventListener("DOMContentLoaded", function () {
        // Get DOM elements
        const methodSelection = document.getElementById("method-selection");
        const pdfUpload = document.getElementById("pdf-upload");
        const textInput = document.getElementById("text-input");
        const manualEntry = document.getElementById("manual-entry");
        const qaReview = document.getElementById("qa-review");
        const downloadPage = document.getElementById("download-page");
        const loadingContainer = document.getElementById("loading-container");
        const loadingText = document.getElementById("loading-text");

        // Direct text input elements
        const directText = document.getElementById("direct-text");
        const wordCount = document.querySelector(".word-count");

        // Carousel elements
        const carouselTrack = document.getElementById("carousel-track");
        const prevBtn = document.getElementById("prev-btn");
        const nextBtn = document.getElementById("next-btn");
        const currentCardSpan = document.getElementById("current-card");
        const totalCardsSpan = document.getElementById("total-cards");
        const carouselPagination = document.getElementById(
          "carousel-pagination"
        );
        const addNewCardBtn = document.getElementById("add-new-card");

        // Grid elements
        const carouselViewBtn = document.getElementById("carousel-view-btn");
        const gridViewBtn = document.getElementById("grid-view-btn");
        const carouselContainer = document.getElementById("flashcard-carousel");
        const gridContainer = document.getElementById("flashcard-grid");
        const gridAddNewCardBtn = document.getElementById("grid-add-new-card");

        const manualForm = document.getElementById("manual-form");

        const youtubeMethod = document.getElementById("youtube-method");
        const youtubeInput = document.getElementById("youtube-input");
        const youtubeBackBtn = document.getElementById("youtube-back-btn");
        const youtubeForm = document.getElementById("youtube-form");

        // Card count estimation handling
        const customCountToggle = document.getElementById(
          "custom-count-toggle"
        );
        const customCountInput = document.querySelector(".custom-count-input");
        const numPairsInput = document.getElementById("num-pairs");
        const estimatedCardCount = document.getElementById(
          "estimated-card-count"
        );
        const densityButtons = document.querySelectorAll(
          "#pdf-upload .density-btn"
        );

        let baseEstimatedCount = 10; // Default value
        let selectedDensity = "recommended"; // Default density

        // Text input card count estimation handling
        const textCustomCountToggle = document.getElementById(
          "text-custom-count-toggle"
        );
        const textCustomCountInput = document.querySelector(
          "#text-input .custom-count-input"
        );
        const textNumPairsInput = document.getElementById("text-num-pairs");
        const textEstimatedCardCount = document.getElementById(
          "text-estimated-card-count"
        );
        const textDensityButtons = document.querySelectorAll(
          "#text-input .density-btn"
        );

        let textBaseEstimatedCount = 10; // Default value
        let textSelectedDensity = "recommended"; // Default density

        // YouTube card count estimation handling
        const youtubeCustomCountToggle = document.getElementById(
          "youtube-custom-count-toggle"
        );
        const youtubeCustomCountInput = document.querySelector(
          "#youtube-input .custom-count-input"
        );
        const youtubeNumPairsInput =
          document.getElementById("youtube-num-pairs");
        const youtubeEstimatedCardCount = document.getElementById(
          "youtube-estimated-card-count"
        );
        const youtubeDensityButtons = document.querySelectorAll(
          "#youtube-input .density-btn"
        );

        let youtubeBaseEstimatedCount = 10; // Default value
        let youtubeSelectedDensity = "recommended"; // Default density

        let currentIndex = 0;
        let allCards = [];
        let currentPdfTaskId = null;

        // File input handling
        const pdfFileInput = document.getElementById("pdf-file");
        const pdfFileName = document.getElementById("pdf-file-name");

        // Manual entry QA pairs container and count
        const qaPairsContainer = document.getElementById("qa-pairs-container");
        let pairCount = 1;

        // PDF form
        const pdfForm = document.getElementById("pdf-form");

        // Text form
        const textForm = document.getElementById("text-form");

        // Toggle custom count input visibility
        if (customCountToggle) {
          customCountToggle.addEventListener("change", function () {
            if (customCountInput) {
              customCountInput.classList.toggle("hidden", !this.checked);
            }
            // Update the form's active count based on selection
            updateActiveCount();
          });
        }

        // Handle density button clicks for PDF form
        if (densityButtons) {
          const pdfDensityContainer = document.querySelector(
            "#pdf-upload .density-selector"
          );

          // Initial tooltip update
          updateTooltipCounts(baseEstimatedCount, pdfDensityContainer);

          densityButtons.forEach((btn) => {
            btn.addEventListener("click", function () {
              // Remove active class from all buttons
              densityButtons.forEach((b) => b.classList.remove("active"));

              // Add active class to clicked button
              this.classList.add("active");

              // Update selected density
              selectedDensity = this.dataset.density;

              // Update the displayed count with visual feedback
              updateDisplayedCardCount(
                baseEstimatedCount,
                selectedDensity,
                estimatedCardCount
              );

              // Update the form value
              if (numPairsInput) {
                numPairsInput.value = updateActiveCount();
              }
            });
          });
        }

        // Update the count based on density selection for PDF form
        function updateActiveCount() {
          let finalCount;

          // If custom count is enabled, use that value
          if (customCountToggle && customCountToggle.checked) {
            finalCount = parseInt(numPairsInput.value) || 10;
          } else {
            // Otherwise calculate based on density
            switch (selectedDensity) {
              case "fewer":
                finalCount = Math.max(5, Math.round(baseEstimatedCount * 0.7));
                break;
              case "more":
                finalCount = Math.min(50, Math.round(baseEstimatedCount * 1.3));
                break;
              default: // recommended
                finalCount = baseEstimatedCount;
            }

            // Update the custom input to match (for if user enables it later)
            if (numPairsInput) {
              numPairsInput.value = finalCount;
            }
          }

          return finalCount;
        }

        // Toggle custom count input visibility for text form
        if (textCustomCountToggle) {
          textCustomCountToggle.addEventListener("change", function () {
            if (textCustomCountInput) {
              textCustomCountInput.classList.toggle("hidden", !this.checked);
            }
            // Update the form's active count based on selection
            updateTextActiveCount();
          });
        }

        // Handle density button clicks for text form
        if (textDensityButtons) {
          const textDensityContainer = document.querySelector(
            "#text-input .density-selector"
          );

          // Initial tooltip update
          updateTooltipCounts(textBaseEstimatedCount, textDensityContainer);

          textDensityButtons.forEach((btn) => {
            btn.addEventListener("click", function () {
              // Remove active class from all buttons
              textDensityButtons.forEach((b) => b.classList.remove("active"));

              // Add active class to clicked button
              this.classList.add("active");

              // Update selected density
              textSelectedDensity = this.dataset.density;

              // Update the displayed count with visual feedback
              updateDisplayedCardCount(
                textBaseEstimatedCount,
                textSelectedDensity,
                textEstimatedCardCount
              );

              // Update the form value
              if (textNumPairsInput) {
                textNumPairsInput.value = updateTextActiveCount();
              }
            });
          });
        }

        // Update the count based on density selection for text form
        function updateTextActiveCount() {
          let finalCount;

          // If custom count is enabled, use that value
          if (textCustomCountToggle && textCustomCountToggle.checked) {
            finalCount = parseInt(textNumPairsInput.value) || 10;
          } else {
            // Otherwise calculate based on density
            switch (textSelectedDensity) {
              case "fewer":
                finalCount = Math.max(
                  5,
                  Math.round(textBaseEstimatedCount * 0.7)
                );
                break;
              case "more":
                finalCount = Math.min(
                  50,
                  Math.round(textBaseEstimatedCount * 1.3)
                );
                break;
              default: // recommended
                finalCount = textBaseEstimatedCount;
            }

            // Update the custom input to match (for if user enables it later)
            if (textNumPairsInput) {
              textNumPairsInput.value = finalCount;
            }
          }

          return finalCount;
        }

        // Toggle custom count input visibility for YouTube form
        if (youtubeCustomCountToggle) {
          youtubeCustomCountToggle.addEventListener("change", function () {
            if (youtubeCustomCountInput) {
              youtubeCustomCountInput.classList.toggle("hidden", !this.checked);
            }
            // Update the form's active count based on selection
            updateYoutubeActiveCount();
          });
        }

        // Handle density button clicks for YouTube form
        if (youtubeDensityButtons) {
          const youtubeDensityContainer = document.querySelector(
            "#youtube-input .density-selector"
          );

          // Initial tooltip update
          updateTooltipCounts(
            youtubeBaseEstimatedCount,
            youtubeDensityContainer
          );

          youtubeDensityButtons.forEach((btn) => {
            btn.addEventListener("click", function () {
              // Remove active class from all buttons
              youtubeDensityButtons.forEach((b) =>
                b.classList.remove("active")
              );

              // Add active class to clicked button
              this.classList.add("active");

              // Update selected density
              youtubeSelectedDensity = this.dataset.density;

              // Update the displayed count with visual feedback
              updateDisplayedCardCount(
                youtubeBaseEstimatedCount,
                youtubeSelectedDensity,
                youtubeEstimatedCardCount
              );

              // Update the form value
              if (youtubeNumPairsInput) {
                youtubeNumPairsInput.value = updateYoutubeActiveCount();
              }
            });
          });
        }
        // Update the count based on density selection for YouTube form
        function updateYoutubeActiveCount() {
          let finalCount;

          // If custom count is enabled, use that value
          if (youtubeCustomCountToggle && youtubeCustomCountToggle.checked) {
            finalCount = parseInt(youtubeNumPairsInput.value) || 10;
          } else {
            // Otherwise calculate based on density
            switch (youtubeSelectedDensity) {
              case "fewer":
                finalCount = Math.max(
                  5,
                  Math.round(youtubeBaseEstimatedCount * 0.7)
                );
                break;
              case "more":
                finalCount = Math.min(
                  50,
                  Math.round(youtubeBaseEstimatedCount * 1.3)
                );
                break;
              default: // recommended
                finalCount = youtubeBaseEstimatedCount;
            }

            // Update the custom input to match (for if user enables it later)
            if (youtubeNumPairsInput) {
              youtubeNumPairsInput.value = finalCount;
            }
          }

          return finalCount;
        }

        // Word counter for direct text input
        if (directText && wordCount) {
          directText.addEventListener("input", () => {
            const count = directText.value.length;
            wordCount.textContent = `${count} characters`;
            wordCount.style.color = count < 100 ? "#dc3545" : "#666";

            // Update estimated card count based on text length
            if (count > 100) {
              // Rough estimate: 1 card per 150 words, ~6 chars per word
              const wordEstimate = Math.round(count / 6);
              textBaseEstimatedCount = Math.max(
                5,
                Math.round(wordEstimate / 150)
              );
              // Round to nearest 5
              textBaseEstimatedCount =
                Math.round(textBaseEstimatedCount / 5) * 5;
              textBaseEstimatedCount = Math.min(textBaseEstimatedCount, 50);

              if (textEstimatedCardCount) {
                textEstimatedCardCount.textContent = textBaseEstimatedCount;
                textEstimatedCardCount.classList.add("count-updated");
                setTimeout(
                  () =>
                    textEstimatedCardCount.classList.remove("count-updated"),
                  600
                );
              }

              // Update tooltip counts
              const textDensityContainer = document.querySelector(
                "#text-input .density-selector"
              );
              updateTooltipCounts(textBaseEstimatedCount, textDensityContainer);

              // Update the displayed count based on density
              updateTextActiveCount();
            }
          });
        }

        // Method selection events
        if (youtubeMethod) {
          youtubeMethod.addEventListener("click", () => showPage(youtubeInput));
        }

        if (youtubeBackBtn) {
          youtubeBackBtn.addEventListener("click", () =>
            showPage(methodSelection)
          );
        }

        const pdfMethod = document.getElementById("pdf-method");
        const textMethod = document.getElementById("text-method");
        const manualMethod = document.getElementById("manual-method");

        if (pdfMethod) {
          pdfMethod.addEventListener("click", () => showPage(pdfUpload));
        }

        if (textMethod) {
          textMethod.addEventListener("click", () => showPage(textInput));
        }

        if (manualMethod) {
          manualMethod.addEventListener("click", () => showPage(manualEntry));
        }

        // Back buttons
        const pdfBackBtn = document.getElementById("pdf-back-btn");
        const textBackBtn = document.getElementById("text-back-btn");
        const manualBackBtn = document.getElementById("manual-back-btn");
        const reviewBackBtn = document.getElementById("review-back-btn");
        const startOverBtn = document.getElementById("start-over-btn");

        if (pdfBackBtn) {
          pdfBackBtn.addEventListener("click", () => showPage(methodSelection));
        }

        if (textBackBtn) {
          textBackBtn.addEventListener("click", () =>
            showPage(methodSelection)
          );
        }

        if (manualBackBtn) {
          manualBackBtn.addEventListener("click", () =>
            showPage(methodSelection)
          );
        }

        if (reviewBackBtn) {
          reviewBackBtn.addEventListener("click", () => {
            const lastMethod = carouselTrack.getAttribute("data-source");
            if (lastMethod === "text") showPage(textInput);
            else if (lastMethod === "pdf") showPage(pdfUpload);
            else showPage(methodSelection);
          });
        }

        if (startOverBtn) {
          startOverBtn.addEventListener("click", () =>
            showPage(methodSelection)
          );
        }

        // File input handling
        if (pdfFileInput && pdfFileName) {
          pdfFileInput.addEventListener("change", (e) => {
            const file = e.target.files[0];
            if (file) {
              const fileSizeMB = file.size / (1024 * 1024);
              if (fileSizeMB > 20) {
                pdfFileName.innerHTML = `<span style="color: #dc3545;">${
                  file.name
                } (${fileSizeMB.toFixed(1)} MB) - File is too large!</span>`;
                alert(
                  "This PDF file is too large (over 20MB). Please upload a smaller file or use the direct text input option."
                );
              } else if (fileSizeMB > 10) {
                pdfFileName.innerHTML = `<span style="color: #ffc107;">${
                  file.name
                } (${fileSizeMB.toFixed(
                  1
                )} MB) - Large file, processing may take longer</span>`;
              } else {
                pdfFileName.innerHTML = `${file.name} (${fileSizeMB.toFixed(
                  1
                )} MB)`;
              }

              // Estimate card count based on file size
              // Rough estimate: 1 page per 100KB, 2.5 cards per page
              const estimatedPages = Math.max(
                1,
                Math.round((fileSizeMB * 1024) / 100)
              );
              baseEstimatedCount = Math.min(
                50,
                Math.max(5, Math.round(estimatedPages * 2.5))
              );
              // Round to nearest 5
              baseEstimatedCount = Math.round(baseEstimatedCount / 5) * 5;

              if (estimatedCardCount) {
                estimatedCardCount.textContent = baseEstimatedCount;
                estimatedCardCount.classList.add("count-updated");
                setTimeout(
                  () => estimatedCardCount.classList.remove("count-updated"),
                  600
                );
              }

              // Update tooltip counts
              const pdfDensityContainer = document.querySelector(
                "#pdf-upload .density-selector"
              );
              updateTooltipCounts(baseEstimatedCount, pdfDensityContainer);

              // Update the displayed count based on current density
              updateActiveCount();
            } else {
              pdfFileName.textContent = "";
            }
          });
        }

        // Form submissions
        if (pdfForm) {
          pdfForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            const file = pdfFileInput.files[0];
            if (!file) {
              alert("Please select a PDF file");
              return;
            }

            // Get the final count based on UI state
            const finalCount = updateActiveCount();

            try {
              loadingContainer.classList.add("show");
              loadingText.textContent = "Analyzing your PDF content...";
              const formData = new FormData();
              formData.append("file", file);
              formData.append("num_pairs", finalCount);

              const response = await fetch(
                `${API_BASE_URL}/upload/pdf?num_pairs=${finalCount}`,
                {
                  method: "POST",
                  body: formData,
                }
              );

              if (!response.ok)
                throw new Error(`HTTP error! status: ${response.status}`);
              const data = await response.json();

              // If we got an estimated count from the server, update our UI
              if (data.estimated_count && estimatedCardCount) {
                baseEstimatedCount = data.estimated_count;
                estimatedCardCount.textContent = baseEstimatedCount;

                // Also update the displayed count based on density
                updateActiveCount();
              }

              currentPdfTaskId = data.task_id;
              pollPdfStatus(currentPdfTaskId);
            } catch (error) {
              console.error("Error:", error);
              loadingContainer.classList.remove("show");
              alert(`Error: ${error.message}`);
            }
          });
        }

        if (textForm) {
          textForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            const text = directText.value.trim();

            // Get the final count based on UI state
            const finalCount = updateTextActiveCount();

            if (!text) {
              alert("Please enter some text");
              return;
            }
            if (text.length < 100) {
              alert(
                "The text is too short. Please provide more content to generate meaningful questions (at least 100 characters)."
              );
              return;
            }

            try {
              loadingContainer.classList.add("show");
              loadingText.textContent = "Analyzing your text content...";
              const response = await fetch(`${API_BASE_URL}/process/text`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ text, num_pairs: parseInt(finalCount) }),
              });

              if (!response.ok)
                throw new Error(`HTTP error! status: ${response.status}`);
              const data = await response.json();

              // If we got an estimated count from the server, update our UI
              if (data.estimated_count && textEstimatedCardCount) {
                textBaseEstimatedCount = data.estimated_count;
                textEstimatedCardCount.textContent = textBaseEstimatedCount;

                // Also update the displayed count based on density
                updateTextActiveCount();
              }

              currentPdfTaskId = data.task_id;
              pollPdfStatus(currentPdfTaskId, "text");
            } catch (error) {
              console.error("Error:", error);
              loadingContainer.classList.remove("show");
              alert(`Error: ${error.message}`);
            }
          });
        }

        // For YouTube URL input
        const youtubeUrlInput = document.getElementById("youtube-url");
        if (youtubeUrlInput) {
          youtubeUrlInput.addEventListener(
            "input",
            debounce(function () {
              const url = this.value.trim();
              if (
                url &&
                /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+/.test(url)
              ) {
                // Valid YouTube URL - make a rough estimate
                // Try to extract video ID and estimate length
                try {
                  const videoId =
                    url.match(/(?:v=|\/)([0-9A-Za-z_-]{11})(?:&|$)/)?.[1] ||
                    url.match(
                      /(?:youtu\.be\/)([0-9A-Za-z_-]{11})(?:\?|$)/
                    )?.[1];

                  if (videoId) {
                    // Default to 10 minute video (10 cards)
                    youtubeBaseEstimatedCount = 10;

                    if (youtubeEstimatedCardCount) {
                      youtubeEstimatedCardCount.textContent =
                        youtubeBaseEstimatedCount;
                      youtubeEstimatedCardCount.classList.add("count-updated");
                      setTimeout(
                        () =>
                          youtubeEstimatedCardCount.classList.remove(
                            "count-updated"
                          ),
                        600
                      );
                    }

                    // Update tooltip counts
                    const youtubeDensityContainer = document.querySelector(
                      "#youtube-input .density-selector"
                    );
                    updateTooltipCounts(
                      youtubeBaseEstimatedCount,
                      youtubeDensityContainer
                    );

                    // Update the displayed count based on current density
                    updateYoutubeActiveCount();
                  }
                } catch (e) {
                  console.error("Error parsing YouTube URL", e);
                }
              }
            }, 500)
          ); // Debounce to avoid too many updates
        }

        // Debounce function to limit how often the handler runs
        function debounce(func, wait) {
          let timeout;
          return function () {
            const context = this,
              args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), wait);
          };
        }

        if (youtubeForm) {
          youtubeForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            const url = document.getElementById("youtube-url").value.trim();

            // Get the final count based on UI state
            const finalCount = updateYoutubeActiveCount();

            if (!url) {
              alert("Please enter a YouTube video URL");
              return;
            }

            // Validate YouTube URL format
            const youtubeRegex =
              /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+/;
            if (!youtubeRegex.test(url)) {
              alert("Please enter a valid YouTube URL");
              return;
            }

            try {
              loadingContainer.classList.add("show");
              loadingText.textContent = "Fetching Video...";
              const response = await fetch(`${API_BASE_URL}/process/youtube`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url, num_pairs: parseInt(finalCount) }),
              });

              if (!response.ok)
                throw new Error(`HTTP error! status: ${response.status}`);
              const data = await response.json();

              // If we got an estimated count from the server, update our UI
              if (data.estimated_count && youtubeEstimatedCardCount) {
                youtubeBaseEstimatedCount = data.estimated_count;
                youtubeEstimatedCardCount.textContent =
                  youtubeBaseEstimatedCount;

                // Also update the displayed count based on density
                updateYoutubeActiveCount();
              }

              pollPdfStatus(data.task_id, "youtube");
            } catch (error) {
              console.error("Error:", error);
              loadingContainer.classList.remove("show");
              alert(`Error: ${error.message}`);
            }
          });
        }

        if (manualForm) {
          manualForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            const title = document.getElementById("deck-title").value;
            const qaPairs = [];
            document.querySelectorAll(".question-input").forEach((input, i) => {
              const question = input.value.trim();
              const answer = document
                .querySelectorAll(".answer-input")
                [i].value.trim();
              if (question && answer) qaPairs.push({ question, answer });
            });
            if (qaPairs.length === 0) {
              alert("Please add at least one question-answer pair");
              return;
            }
            createDeckFromQAPairs(qaPairs, title);
          });
        }

        // Add new QA pair in manual entry
        const addPairBtn = document.getElementById("add-pair");
        if (addPairBtn) {
          addPairBtn.addEventListener("click", () => {
            pairCount++;
            const newPair = document.createElement("div");
            newPair.className = "qa-pair";
            newPair.innerHTML = `
        <div class="qa-pair-header">
          <div class="qa-pair-num">Card #${pairCount}</div>
          <button type="button" class="remove-pair" title="Remove this card"></button>
        </div>
        <div class="form-group">
          <label for="question-${pairCount - 1}">Question</label>
          <input type="text" id="question-${
            pairCount - 1
          }" class="question-input" required placeholder="Enter your question">
        </div>
        <div class="form-group">
          <label for="answer-${pairCount - 1}">Answer</label>
          <textarea id="answer-${
            pairCount - 1
          }" class="answer-input" required placeholder="Enter your answer" rows="3"></textarea>
        </div>
      `;
            qaPairsContainer.appendChild(newPair);
            newPair
              .querySelector(".remove-pair")
              .addEventListener("click", function () {
                if (document.querySelectorAll(".qa-pair").length > 1) {
                  newPair.remove();
                  pairCount--;
                  updateManualPairNumbers();
                } else {
                  alert("You need at least one question-answer pair");
                }
              });
          });
        }

        // Add remove button to first QA pair in manual entry if missing
        const firstPair = qaPairsContainer
          ? qaPairsContainer.querySelector(".qa-pair")
          : null;
        if (firstPair && !firstPair.querySelector(".remove-pair")) {
          const header = firstPair.querySelector(".qa-pair-header");
          if (header) {
            const removeBtn = document.createElement("button");
            removeBtn.type = "button";
            removeBtn.className = "remove-pair";
            removeBtn.title = "Remove this pair";
            removeBtn.textContent = "";
            header.appendChild(removeBtn);
            removeBtn.addEventListener("click", function () {
              if (document.querySelectorAll(".qa-pair").length > 1) {
                firstPair.remove();
                pairCount--;
                updateManualPairNumbers();
              } else {
                alert("You need at least one question-answer pair");
              }
            });
          }
        }

        // Toggle view events
        if (carouselViewBtn && gridViewBtn) {
          carouselViewBtn.addEventListener("click", function () {
            carouselViewBtn.classList.add("active");
            gridViewBtn.classList.remove("active");
            carouselContainer.classList.remove("hidden");
            gridContainer.classList.add("hidden");
            if (gridAddNewCardBtn) gridAddNewCardBtn.classList.add("hidden");
            if (addNewCardBtn) addNewCardBtn.classList.remove("hidden");
          });

          gridViewBtn.addEventListener("click", function () {
            gridViewBtn.classList.add("active");
            carouselViewBtn.classList.remove("active");
            gridContainer.classList.remove("hidden");
            carouselContainer.classList.add("hidden");
            if (addNewCardBtn) addNewCardBtn.classList.add("hidden");
            if (gridAddNewCardBtn) gridAddNewCardBtn.classList.remove("hidden");
            populateGridView();
          });
        }

        if (gridAddNewCardBtn) {
          gridAddNewCardBtn.addEventListener("click", function () {
            const currentCards = JSON.parse(
              carouselTrack.getAttribute("data-cards")
            );
            const source = carouselTrack.getAttribute("data-source");
            const taskId = carouselTrack.getAttribute("data-task-id");
            currentCards.push({ question: "", answer: "" });
            allCards = currentCards;
            carouselTrack.setAttribute(
              "data-cards",
              JSON.stringify(currentCards)
            );
            populateGridView();
            gridContainer.scrollTop = gridContainer.scrollHeight;
          });
        }

        // Create deck from QA review page
        const createDeckFromQABtn = document.getElementById(
          "create-deck-from-qa"
        );
        if (createDeckFromQABtn) {
          createDeckFromQABtn.addEventListener("click", function () {
            const cardsData = JSON.parse(
              document
                .getElementById("carousel-track")
                .getAttribute("data-cards") || "[]"
            );
            if (cardsData.length === 0) {
              alert("Error: No flashcards found");
              return;
            }
            const invalidCards = cardsData.filter(
              (card) => !card.question.trim() || !card.answer.trim()
            );
            if (invalidCards.length > 0) {
              alert(
                `Error: ${invalidCards.length} cards have empty questions or answers. Please complete all cards.`
              );
              return;
            }
            const deckTitle = prompt(
              "Enter a title for your Anki deck:",
              "My Flashcards"
            );
            if (!deckTitle) return;
            createDeckFromQAPairs(cardsData, deckTitle);
          });
        }

        // Download deck event
        const downloadDeckBtn = document.getElementById("download-deck");
        if (downloadDeckBtn) {
          downloadDeckBtn.addEventListener("click", function () {
            const taskId = this.getAttribute("data-task-id");
            if (taskId)
              window.location.href = `${API_BASE_URL}/download/${taskId}`;
            else alert("Error: Task ID not found.");
          });
        }

        // Keyboard navigation for carousel view
        document.addEventListener("keydown", function (e) {
          if (
            qaReview.classList.contains("active") &&
            gridContainer.classList.contains("hidden")
          ) {
            if (e.key === "ArrowLeft" && currentIndex > 0) {
              currentIndex--;
              updateCarouselDisplay();
            } else if (
              e.key === "ArrowRight" &&
              currentIndex < allCards.length - 1
            ) {
              currentIndex++;
              updateCarouselDisplay();
            }
          }
        });

        // Helper functions
        function showPage(page) {
          document
            .querySelectorAll(".page")
            .forEach((p) => p.classList.remove("active"));
          page.classList.add("active");
        }

        // Poll for PDF/text processing status
        async function pollPdfStatus(taskId, source = "pdf") {
          try {
            const response = await fetch(`${API_BASE_URL}/status/${taskId}`);
            if (!response.ok)
              throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();

            // If we get an estimated count from the server, update our UI
            if (data.estimated_count) {
              if (source === "pdf" && estimatedCardCount) {
                baseEstimatedCount = data.estimated_count;
                estimatedCardCount.textContent = baseEstimatedCount;
                updateActiveCount();
              } else if (source === "text" && textEstimatedCardCount) {
                textBaseEstimatedCount = data.estimated_count;
                textEstimatedCardCount.textContent = textBaseEstimatedCount;
                updateTextActiveCount();
              } else if (source === "youtube" && youtubeEstimatedCardCount) {
                youtubeBaseEstimatedCount = data.estimated_count;
                youtubeEstimatedCardCount.textContent =
                  youtubeBaseEstimatedCount;
                updateYoutubeActiveCount();
              }
            }

            if (data.message) loadingText.textContent = data.message;
            if (data.status === "completed") {
              fetchQAPairs(taskId, source);
            } else if (data.status === "failed") {
              loadingContainer.classList.remove("show");
              alert(data.message || "An error occurred during processing.");
            } else {
              setTimeout(() => pollPdfStatus(taskId, source), 1000);
            }
          } catch (error) {
            console.error("Error polling status:", error);
            loadingContainer.classList.remove("show");
            alert(`Error checking status: ${error.message}`);
          }
        }

        async function fetchQAPairs(taskId, source) {
          try {
            const response = await fetch(`${API_BASE_URL}/qa-pairs/${taskId}`);
            if (!response.ok)
              throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            allCards = data.qa_pairs;
            setupCarousel(allCards, source, taskId);
            loadingContainer.classList.remove("show");
            showPage(qaReview);
          } catch (error) {
            console.error("Error fetching QA pairs:", error);
            loadingContainer.classList.remove("show");
            alert(`Error fetching QA pairs: ${error.message}`);
          }
        }

        // Set up the flashcard carousel
        function setupCarousel(cards, source, taskId) {
          allCards = cards;
          currentIndex = Math.min(currentIndex, cards.length - 1);
          if (currentIndex < 0 && cards.length > 0) currentIndex = 0;
          carouselTrack.innerHTML = "";
          carouselTrack.setAttribute("data-source", source);
          carouselTrack.setAttribute("data-task-id", taskId);
          carouselTrack.setAttribute("data-cards", JSON.stringify(cards));

          cards.forEach((card, index) => {
            const cardElement = document.createElement("div");
            cardElement.className = "qa-pair";
            cardElement.dataset.index = index;
            cardElement.innerHTML = `
        <div class="qa-pair-header">
          <div class="qa-pair-num">Card #${index + 1}</div>
          <button type="button" class="remove-pair" title="Remove this card"></button>
        </div>
        <div class="form-group">
          <label for="carousel-question-${index}">Question:</label>
          <textarea id="carousel-question-${index}" class="edit-question" rows="3">${
              card.question
            }</textarea>
        </div>
        <div class="form-group">
          <label for="carousel-answer-${index}">Answer:</label>
          <textarea id="carousel-answer-${index}" class="edit-answer" rows="4">${
              card.answer
            }</textarea>
        </div>
      `;
            carouselTrack.appendChild(cardElement);
            cardElement
              .querySelector(".remove-pair")
              .addEventListener("click", function () {
                if (cards.length > 1) {
                  const currentCards = JSON.parse(
                    carouselTrack.getAttribute("data-cards")
                  );
                  const currentCardIndex = currentIndex;
                  currentCards.splice(index, 1);
                  carouselTrack.setAttribute(
                    "data-cards",
                    JSON.stringify(currentCards)
                  );
                  let newIndex =
                    index < currentCardIndex
                      ? currentCardIndex - 1
                      : index === currentCardIndex
                      ? Math.max(0, currentCardIndex - 1)
                      : currentCardIndex;
                  newIndex = Math.min(newIndex, currentCards.length - 1);
                  allCards = currentCards;
                  setupCarousel(currentCards, source, taskId);
                  goToCard(newIndex);
                } else {
                  alert("You need at least one flashcard");
                }
              });
          });

          totalCardsSpan.textContent = cards.length;
          currentCardSpan.textContent = currentIndex + 1;
          updateCarouselPagination(cards.length);
          updateCarouselDisplay();
          setupCarouselControls();
          if (gridContainer && !gridContainer.classList.contains("hidden")) {
            populateGridView();
          }
        }

        function updateCarouselPagination(totalCards) {
          carouselPagination.innerHTML = "";
          for (let i = 0; i < totalCards; i++) {
            const dot = document.createElement("div");
            dot.className = "pagination-dot";
            if (i === currentIndex) dot.classList.add("active");
            dot.addEventListener("click", () => goToCard(i));
            carouselPagination.appendChild(dot);
          }
        }

        function updateCarouselDisplay() {
          if (currentIndex >= allCards.length)
            currentIndex = allCards.length - 1;
          carouselTrack.style.transform = `translateX(-${currentIndex * 100}%)`;
          currentCardSpan.textContent = currentIndex + 1;
          totalCardsSpan.textContent = allCards.length;
          carouselPagination
            .querySelectorAll(".pagination-dot")
            .forEach((dot, index) => {
              dot.classList.toggle("active", index === currentIndex);
            });
          prevBtn.disabled = currentIndex === 0;
          nextBtn.disabled = currentIndex === allCards.length - 1;
        }

        function updateDisplayedCardCount(baseCount, density, displayElement) {
          if (!displayElement) return;

          let finalCount;
          switch (density) {
            case "fewer":
              finalCount = Math.max(5, Math.round(baseCount * 0.7));
              break;
            case "more":
              finalCount = Math.min(50, Math.round(baseCount * 1.3));
              break;
            default: // recommended
              finalCount = baseCount;
          }

          displayElement.textContent = finalCount;

          // Add visual feedback when count changes
          displayElement.classList.add("count-updated");
          setTimeout(
            () => displayElement.classList.remove("count-updated"),
            600
          );

          return finalCount;
        }

        function updateTooltipCounts(baseCount, container) {
          if (!container) return;

          const fewerCount = Math.max(5, Math.round(baseCount * 0.7));
          const moreCount = Math.min(50, Math.round(baseCount * 1.3));

          const fewerElem = container.querySelector(".fewer-count");
          const recommendedElem = container.querySelector(".recommended-count");
          const moreElem = container.querySelector(".more-count");

          if (fewerElem) fewerElem.textContent = fewerCount;
          if (recommendedElem) recommendedElem.textContent = baseCount;
          if (moreElem) moreElem.textContent = moreCount;
        }

        function setupCarouselControls() {
          prevBtn.onclick = () => {
            if (currentIndex > 0) {
              currentIndex--;
              updateCarouselDisplay();
            }
          };
          nextBtn.onclick = () => {
            if (currentIndex < allCards.length - 1) {
              currentIndex++;
              updateCarouselDisplay();
            }
          };
          if (addNewCardBtn) {
            addNewCardBtn.onclick = () => {
              const currentCards = JSON.parse(
                carouselTrack.getAttribute("data-cards")
              );
              const source = carouselTrack.getAttribute("data-source");
              const taskId = carouselTrack.getAttribute("data-task-id");
              currentCards.push({ question: "", answer: "" });
              allCards = currentCards;
              carouselTrack.setAttribute(
                "data-cards",
                JSON.stringify(currentCards)
              );
              setupCarousel(currentCards, source, taskId);
              goToCard(currentCards.length - 1);
            };
          }
        }

        function goToCard(index) {
          if (index >= 0 && index < allCards.length) {
            currentIndex = index;
            updateCarouselDisplay();
          }
        }

        function populateGridView() {
          const cards = JSON.parse(
            carouselTrack.getAttribute("data-cards") || "[]"
          );
          const source = carouselTrack.getAttribute("data-source");
          const taskId = carouselTrack.getAttribute("data-task-id");
          gridContainer.innerHTML = "";
          cards.forEach((card, index) => {
            const gridItem = document.createElement("div");
            gridItem.className = "grid-item";
            gridItem.dataset.index = index;
            gridItem.innerHTML = `
        <div class="grid-item-header">
          <div class="qa-pair-num">Card #${index + 1}</div>
          <button type="button" class="remove-pair" title="Remove this card"></button>
        </div>
        <div class="form-group">
          <label for="grid-question-${index}">Question:</label>
          <textarea id="grid-question-${index}" class="edit-question" rows="2">${
              card.question
            }</textarea>
        </div>
        <div class="form-group">
          <label for="grid-answer-${index}">Answer:</label>
          <textarea id="grid-answer-${index}" class="edit-answer" rows="3">${
              card.answer
            }</textarea>
        </div>
      `;
            gridContainer.appendChild(gridItem);
            const questionTextarea = gridItem.querySelector(".edit-question");
            const answerTextarea = gridItem.querySelector(".edit-answer");
            questionTextarea.addEventListener("input", function () {
              cards[index].question = this.value;
              carouselTrack.setAttribute("data-cards", JSON.stringify(cards));
              const carouselQuestion = document.getElementById(
                `carousel-question-${index}`
              );
              if (carouselQuestion) carouselQuestion.value = this.value;
            });
            answerTextarea.addEventListener("input", function () {
              cards[index].answer = this.value;
              carouselTrack.setAttribute("data-cards", JSON.stringify(cards));
              const carouselAnswer = document.getElementById(
                `carousel-answer-${index}`
              );
              if (carouselAnswer) carouselAnswer.value = this.value;
            });
            gridItem
              .querySelector(".remove-pair")
              .addEventListener("click", function () {
                if (cards.length > 1) {
                  const currentCardIndex = currentIndex;
                  cards.splice(index, 1);
                  carouselTrack.setAttribute(
                    "data-cards",
                    JSON.stringify(cards)
                  );
                  let newIndex =
                    index < currentCardIndex
                      ? currentCardIndex - 1
                      : index === currentCardIndex
                      ? Math.max(0, currentCardIndex - 1)
                      : currentCardIndex;
                  newIndex = Math.min(newIndex, cards.length - 1);
                  allCards = cards;
                  setupCarousel(cards, source, taskId);
                  populateGridView();
                  goToCard(newIndex);
                } else {
                  alert("You need at least one flashcard");
                }
              });
          });
        }

        async function createDeckFromQAPairs(qaPairs, title) {
          try {
            loadingContainer.classList.add("show");
            loadingText.textContent = "Creating your Anki deck...";
            const apiData = { title, qa_pairs: qaPairs };
            const response = await fetch(`${API_BASE_URL}/generate-deck`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(apiData),
            });
            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(
                `HTTP error! status: ${response.status}, message: ${errorText}`
              );
            }
            const data = await response.json();
            pollDeckStatus(data.task_id);
          } catch (error) {
            console.error("Error creating deck:", error);
            loadingContainer.classList.remove("show");
            alert(`Error creating deck: ${error.message}`);
          }
        }

        // Poll for deck creation status
        async function pollDeckStatus(taskId) {
          try {
            const response = await fetch(`${API_BASE_URL}/status/${taskId}`);
            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(
                `HTTP error! status: ${response.status}, message: ${errorText}`
              );
            }
            const data = await response.json();
            if (data.message) loadingText.textContent = data.message;
            if (data.status === "completed") {
              document
                .getElementById("download-deck")
                .setAttribute("data-task-id", taskId);
              loadingContainer.classList.remove("show");
              showPage(downloadPage);
              showNotification("Deck created successfully!");
            } else if (data.status === "failed") {
              loadingContainer.classList.remove("show");
              alert(
                data.message || "An error occurred while creating the deck."
              );
            } else {
              setTimeout(() => pollDeckStatus(taskId), 1000);
            }
          } catch (error) {
            console.error("Error polling status:", error);
            loadingContainer.classList.remove("show");
            alert(`Error checking status: ${error.message}`);
          }
        }

        // Show notification
        function showNotification(message) {
          const notification = document.getElementById("notification");
          notification.textContent = message;
          notification.classList.add("show");
          setTimeout(() => notification.classList.remove("show"), 3000);
        }

        // Update manual entry pair numbers
        function updateManualPairNumbers() {
          document
            .querySelectorAll("#qa-pairs-container .qa-pair")
            .forEach((pair, index) => {
              pair.querySelector(".qa-pair-num").textContent = `Card #${
                index + 1
              }`;
            });
        }
      });
    </script>
  </body>
</html>
